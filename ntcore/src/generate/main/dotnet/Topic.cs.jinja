// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

// THIS FILE WAS AUTO-GENERATED BY ./ntcore/generate_topics.py. DO NOT MODIFY

using System;
using NetworkTables.Handles;
using NetworkTables.Natives;

namespace NetworkTables;

/// <summary>
/// NetworkTables {{ TypeName }} topic.
/// </summary>
public class {{ TypeName }}Topic : Topic
{
{%- if TypeString %}
    /// <summary>
    /// The default type string for this topic type
    /// </summary>
    public static string kTypeString => {{ TypeString }};
    /// <summary>
    /// The default type string for this topic type in a UTF8 Span
    /// </summary>
    public static ReadOnlySpan<byte> kTypeStringUtf8 => {{ TypeString }}u8;
{% endif %}
    /// <summary>
    /// Constructs a typed topic from a generic topic.
    /// </summary>
    /// <param name="topic">typed topic</param>
    public {{ TypeName }}Topic(Topic topic) : base(topic.Instance, topic.Handle) { }

    /// <summary>
    /// Constructor; use NetworkTableInstance.Get{{ TypeName}}Topic() instead.
    /// </summary>
    /// <param name="inst">Instance</param>
    /// <param name="handle">Native handle</param>
    public {{ TypeName }}Topic(NetworkTableInstance inst, NtTopic handle) : base(inst, handle) { }

{% if TypeString %}
    /// <summary>
    /// Create a new subscriver to the topic.
    /// </summary>
    /// <remarks>
    /// The subscriber is only active as long as the returned object is not closed.
    ///
    /// Subscribers that do not match the published data type do not return any
    /// values. To determine if the data type matches, use the appropriate Topic
    /// functions.
    /// </remarks>
    /// <param name="defaultValue">
    /// default value used when a default is not provided to a getter function
    /// </param>
    /// <param name="options">subscribe options</param>
    /// <returns>subscriber</returns>
    public I{{ TypeName }}Subscriber Subscribe(
        {{ dotnet.ValueType }} defaultValue,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtSubscriber>(
            this,
            NtCore.Subscribe(
                Handle, NetworkTableType.{{ TypeName }},
                {{ TypeString }}u8, options),
            defaultValue);
    }

    /// <summary>
    /// Create a new subscriber to the topic, with the specified type string.
    /// </summary>
    /// <remarks>
    /// The subscriber is only active as long as the returned object is not closed.
    ///
    /// Subscribers that do not match the published data type do not return any
    /// values. To determine if the data type matches, use the appropriate Topic
    /// functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="defaultValue">
    /// default value used when a default is not provided to a getter function
    /// </param>
    /// <param name="options">subscribe options</param>
    /// <returns>subscriber</returns>
    public I{{ TypeName }}Subscriber SubscribeEx(
        string typeString,
        {{ dotnet.ValueType }} defaultValue,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtSubscriber>(
            this,
            NtCore.Subscribe(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, options),
            defaultValue);
    }

    /// <summary>
    /// Create a new subscriber to the topic, with the specified type string.
    /// </summary>
    /// <remarks>
    /// The subscriber is only active as long as the returned object is not closed.
    ///
    /// Subscribers that do not match the published data type do not return any
    /// values. To determine if the data type matches, use the appropriate Topic
    /// functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="defaultValue">
    /// default value used when a default is not provided to a getter function
    /// </param>
    /// <param name="options">subscribe options</param>
    /// <returns>subscriber</returns>
    public I{{ TypeName }}Subscriber SubscribeEx(
        ReadOnlySpan<byte> typeString,
        {{ dotnet.ValueType }} defaultValue,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtSubscriber>(
            this,
            NtCore.Subscribe(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, options),
            defaultValue);
    }

    /// <summary>
    /// Create a new publisher to the topic.
    /// </summary>
    /// <remarks>
    /// The publisher is only active as long as the returned object is not closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="options">publish options</param>
    /// <returns>publisher</returns>
    public I{{ TypeName }}Publisher Publish(
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtPublisher>(
            this,
            NtCore.Publish(
                Handle, NetworkTableType.{{ TypeName }},
                {{ TypeString }}u8, options),
            {{ dotnet.EmptyValue }});
    }

    /// <summary>
    /// Create a new publisher to the topic, with type string and initial properties.
    /// </summary>
    /// <remarks>
    /// The publisher is only active as long as the returned object is not closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="properties">JSON properties</param>
    /// <param name="options">publish options</param>
    /// <returns>publisher</returns>
    public I{{ TypeName }}Publisher PublishEx(
        string typeString, string properties,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtPublisher>(
            this,
            NtCore.PublishEx(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, properties, options),
            {{ dotnet.EmptyValue }});
    }

    /// <summary>
    /// Create a new publisher to the topic, with type string and initial properties.
    /// </summary>
    /// <remarks>
    /// The publisher is only active as long as the returned object is not closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="properties">JSON properties</param>
    /// <param name="options">publish options</param>
    /// <returns>publisher</returns>
    public I{{ TypeName }}Publisher PublishEx(
        ReadOnlySpan<byte> typeString,
        string properties,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtPublisher>(
            this,
            NtCore.PublishEx(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, properties, options),
            {{ dotnet.EmptyValue }});
    }

    /// <summary>
    /// Create a new publisher to the topic, with type string and initial properties.
    /// </summary>
    /// <remarks>
    /// The publisher is only active as long as the returned object is not closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="properties">JSON properties</param>
    /// <param name="options">publish options</param>
    /// <returns>publisher</returns>
    public I{{ TypeName }}Publisher PublishEx(
        string typeString,
        ReadOnlySpan<byte> properties,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtPublisher>(
            this,
            NtCore.PublishEx(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, properties, options),
            {{ dotnet.EmptyValue }});
    }

    /// <summary>
    /// Create a new publisher to the topic, with type string and initial properties.
    /// </summary>
    /// <remarks>
    /// The publisher is only active as long as the returned object is not closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="properties">JSON properties</param>
    /// <param name="options">publish options</param>
    /// <returns>publisher</returns>
    public I{{ TypeName }}Publisher PublishEx(
        ReadOnlySpan<byte> typeString,
        ReadOnlySpan<byte> properties,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtPublisher>(
            this,
            NtCore.PublishEx(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, properties, options),
            {{ dotnet.EmptyValue }});
    }

    /// <summary>
    /// Create a new entry for the topic.
    /// </summary>
    /// <remarks>
    /// Entries act as a combination of a subscriber and a weak publisher. The
    /// subscriber is active as long as the entry is not closed. The publisher is
    /// created when the entry is first written to, and remains active until either
    /// Unpublish() is called or the entry is closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="defaultValue">
    /// default value used when a default is not provided to a getter function
    /// </param>
    /// <param name="options">publish and/or subscribe options</param>
    /// <returns>entry</returns>
    public I{{ TypeName }}Entry GetEntry(
        {{ dotnet.ValueType }} defaultValue,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtEntry>(
            this,
            NtCore.GetEntry(
                Handle, NetworkTableType.{{ TypeName }},
                {{ TypeString }}u8, options),
            defaultValue);
    }

    /// <summary>
    /// Create a new entry for the topic, with the specified type string.
    /// </summary>
    /// <remarks>
    /// Entries act as a combination of a subscriber and a weak publisher. The
    /// subscriber is active as long as the entry is not closed. The publisher is
    /// created when the entry is first written to, and remains active until either
    /// Unpublish() is called or the entry is closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="defaultValue">
    /// default value used when a default is not provided to a getter function
    /// </param>
    /// <param name="options">publish and/or subscribe options</param>
    /// <returns>entry</returns>
    public I{{ TypeName }}Entry GetEntryEx(
        string typeString,
        {{ dotnet.ValueType }} defaultValue,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtEntry>(
            this,
            NtCore.GetEntry(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, options),
            defaultValue);
    }

    /// <summary>
    /// Create a new entry for the topic, with the specified type string.
    /// </summary>
    /// <remarks>
    /// Entries act as a combination of a subscriber and a weak publisher. The
    /// subscriber is active as long as the entry is not closed. The publisher is
    /// created when the entry is first written to, and remains active until either
    /// Unpublish() is called or the entry is closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="defaultValue">
    /// default value used when a default is not provided to a getter function
    /// </param>
    /// <param name="options">publish and/or subscribe options</param>
    /// <returns>entry</returns>
    public I{{ TypeName }}Entry GetEntryEx(
        ReadOnlySpan<byte> typeString,
        {{ dotnet.ValueType }} defaultValue,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtEntry>(
            this,
            NtCore.GetEntry(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, options),
            defaultValue);
    }
{% else %}
    /// <summary>
    /// Create a new subscriber to the topic, with the specified type string.
    /// </summary>
    /// <remarks>
    /// The subscriber is only active as long as the returned object is not closed.
    ///
    /// Subscribers that do not match the published data type do not return any
    /// values. To determine if the data type matches, use the appropriate Topic
    /// functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="defaultValue">
    /// default value used when a default is not provided to a getter function
    /// </param>
    /// <param name="options">subscribe options</param>
    /// <returns>subscriber</returns>
    public I{{ TypeName }}Subscriber Subscribe(
        string typeString,
        {{ dotnet.ValueType }} defaultValue,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtSubscriber>(
            this,
            NtCore.Subscribe(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, options),
            defaultValue);
    }

    /// <summary>
    /// Create a new subscriber to the topic.
    /// </summary>
    /// <remarks>
    /// The subscriber is only active as long as the returned object is not closed.
    ///
    /// Subscribers that do not match the published data type do not return any
    /// values. To determine if the data type matches, use the appropriate Topic
    /// functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="defaultValue">
    /// default value used when a default is not provided to a getter function
    /// </param>
    /// <param name="options">subscribe options</param>
    /// <returns>subscriber</returns>
    public I{{ TypeName }}Subscriber Subscribe(
        ReadOnlySpan<byte> typeString,
        {{ dotnet.ValueType }} defaultValue,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtSubscriber>(
            this,
            NtCore.Subscribe(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, options),
            defaultValue);
    }

    /// <summary>
    /// Create a new publisher to the topic.
    /// </summary>
    /// <remarks>
    /// The publisher is only active as long as the returned object is not closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="options">publish options</param>
    /// <returns>publisher</returns>
    public I{{ TypeName }}Publisher Publish(
        string typeString,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtPublisher>(
            this,
            NtCore.Publish(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, options),
            {{ dotnet.EmptyValue }});
    }

    /// <summary>
    /// Create a new publisher to the topic.
    /// </summary>
    /// <remarks>
    /// The publisher is only active as long as the returned object is not closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="options">publish options</param>
    /// <returns>publisher</returns>
    public I{{ TypeName }}Publisher Publish(
        ReadOnlySpan<byte> typeString,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtPublisher>(
            this,
            NtCore.Publish(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, options),
            {{ dotnet.EmptyValue }});
    }

    /// <summary>
    /// Create a new publisher to the topic, with type string and initial properties.
    /// </summary>
    /// <remarks>
    /// The publisher is only active as long as the returned object is not closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="properties">JSON properties</param>
    /// <param name="options">publish options</param>
    /// <returns>publisher</returns>
    public I{{ TypeName }}Publisher PublishEx(
        string typeString, string properties,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtPublisher>(
            this,
            NtCore.PublishEx(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, properties, options),
            {{ dotnet.EmptyValue }});
    }

    /// <summary>
    /// Create a new publisher to the topic, with type string and initial properties.
    /// </summary>
    /// <remarks>
    /// The publisher is only active as long as the returned object is not closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="properties">JSON properties</param>
    /// <param name="options">publish options</param>
    /// <returns>publisher</returns>
    public I{{ TypeName }}Publisher PublishEx(
        ReadOnlySpan<byte> typeString,
        string properties,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtPublisher>(
            this,
            NtCore.PublishEx(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, properties, options),
            {{ dotnet.EmptyValue }});
    }

    /// <summary>
    /// Create a new publisher to the topic, with type string and initial properties.
    /// </summary>
    /// <remarks>
    /// The publisher is only active as long as the returned object is not closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="properties">JSON properties</param>
    /// <param name="options">publish options</param>
    /// <returns>publisher</returns>
    public I{{ TypeName }}Publisher PublishEx(
        string typeString,
        ReadOnlySpan<byte> properties,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtPublisher>(
            this,
            NtCore.PublishEx(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, properties, options),
            {{ dotnet.EmptyValue }});
    }

    /// <summary>
    /// Create a new publisher to the topic, with type string and initial properties.
    /// </summary>
    /// <remarks>
    /// The publisher is only active as long as the returned object is not closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="properties">JSON properties</param>
    /// <param name="options">publish options</param>
    /// <returns>publisher</returns>
    public I{{ TypeName }}Publisher PublishEx(
        ReadOnlySpan<byte> typeString,
        ReadOnlySpan<byte> properties,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtPublisher>(
            this,
            NtCore.PublishEx(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, properties, options),
            {{ dotnet.EmptyValue }});
    }

    /// <summary>
    /// Create a new entry for the topic, with the specified type string.
    /// </summary>
    /// <remarks>
    /// Entries act as a combination of a subscriber and a weak publisher. The
    /// subscriber is active as long as the entry is not closed. The publisher is
    /// created when the entry is first written to, and remains active until either
    /// Unpublish() is called or the entry is closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="defaultValue">
    /// default value used when a default is not provided to a getter function
    /// </param>
    /// <param name="options">publish and/or subscribe options</param>
    /// <returns>entry</returns>
    public I{{ TypeName }}Entry GetEntry(
        string typeString,
        {{ dotnet.ValueType }} defaultValue,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtEntry>(
            this,
            NtCore.GetEntry(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, options),
            defaultValue);
    }

    /// <summary>
    /// Create a new entry for the topic, with the specified type string.
    /// </summary>
    /// <remarks>
    /// Entries act as a combination of a subscriber and a weak publisher. The
    /// subscriber is active as long as the entry is not closed. The publisher is
    /// created when the entry is first written to, and remains active until either
    /// Unpublish() is called or the entry is closed.
    ///
    /// It is not possible to publish two different data types to the same topic.
    /// Conflicts between publishers are typically resolved by the server on a
    /// first-come, first-served basis. Any published values that do not match
    /// the topic's data type are dropped (ignored). To determine if the data
    /// type matches, use tha appropriate Topic functions.
    /// </remarks>
    /// <param name="typeString">type string</param>
    /// <param name="defaultValue">
    /// default value used when a default is not provided to a getter function
    /// </param>
    /// <param name="options">publish and/or subscribe options</param>
    /// <returns>entry</returns>
    public I{{ TypeName }}Entry GetEntry(
        ReadOnlySpan<byte> typeString,
        {{ dotnet.ValueType }} defaultValue,
        PubSubOptions options)
    {
        return new {{ TypeName }}EntryImpl<NtEntry>(
            this,
            NtCore.GetEntry(
                Handle, NetworkTableType.{{ TypeName }},
                typeString, options),
            defaultValue);
    }
{% endif %}
}
