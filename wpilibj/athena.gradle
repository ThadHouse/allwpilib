apply plugin: 'cpp'

def jniDir = 'src/athena/cpp'
def generatedJNIHeaderLoc = "$buildDir/include"
def ntSourceDir = "$buildDir/ntSources"

debugStripSetup(project)

sourceSets {
    athena
}

dependencies {
    athenaCompile sourceSets.shared.output
    athenaCompile 'edu.wpi.first.wpilib.networktables.java:NetworkTables:+:arm'
    athenaRuntime 'edu.wpi.first.wpilib.networktables.java:NetworkTables:+:arm'
}

defineWpiUtilProperties()

// Configuration for the HAL bindings
model {
    components {
        wpilibJavaJNI(NativeLibrarySpec) {
            targetPlatform 'arm'
            binaries.all {
                tasks.withType(CppCompile) {
                    dependsOn jniHeaders
                    addNiLibraryLinks(linker, targetPlatform)
                    addWpiUtilLibraryLinks(it, linker, targetPlatform)
                }
            }
            sources {
                cpp {
                    source {
                        srcDirs = ["$jniDir/lib"]
                        includes = ['**/*.cpp']
                    }
                    exportedHeaders {
                        // JDK is included for jni.h. We also need the arm-linux specific headers. This does not need to change
                        // when compiling on Windows
                        // The JNI headers are put into the build/include directory by the jniHeaders task on wpilibJavaDevices
                        srcDirs = ["$jniDir/include", "$jniDir/include/linux", wpiUtilInclude]
                        jniHeaders.outputs.files.each { file ->
                            srcDirs file.getPath()
                        }
                    }
                    lib project: ':hal', library: 'HALAthena', linkage: 'shared'
                }
            }
        }
    }
}

// Maven publishing configuration
publishing {
    publications {
        wpilibj(MavenPublication) {
            artifact jar
            artifact(wpilibjSources) {
                classifier "sources"
            }
            artifact(wpilibjJavadoc) {
                classifier "javadoc"
            }

            groupId 'edu.wpi.first.wpilibj'
            artifactId 'athena'
            version WPILibVersion.version
        }
        wpilibjjni(MavenPublication) {
            artifact wpilibjNativeLibraries

            groupId 'edu.wpi.first.wpilibj'
            artifactId 'athena-jni'
            version WPILibVersion.version
        }
    }

    setupWpilibRepo(it)
}

jar {
    dependsOn { classes }

    doFirst {
        def addClasspath = { classpath ->
            classpath.files.findAll { it.exists() }.each {
                if (file(it).directory) {
                    from it
                } else {
                    from zipTree(it.path)
                }
            }
        }
        addClasspath sourceSets.athena.runtimeClasspath
    }
}

tasks.whenTaskAdded { task ->
    if (task.name == 'wpilibJavaJNISharedLibrary') {
        jar.dependsOn task
        wpilibjNativeLibraries.dependsOn task
    }
}

task wpilibjSources(type: Jar, dependsOn: classes) {
    description = 'Creates the sources jar for the maven publishing routine'
    group = 'WPILib'
    classifier = 'sources'
    duplicatesStrategy = 'exclude'

    from sourceSets.athena.allJava
    from sourceSets.shared.allJava
}

task unzipJavaNtSources(type: Copy) {
    description = 'Unzips the java networktables sources for doc creation'
    group = 'WPILib'
    doFirst {
        def ntSourcesDependency =
        project.dependencies.create('edu.wpi.first.wpilib.networktables.java:NetworkTables:+:sources@jar')
        def ntSourcesConfig = project.configurations.detachedConfiguration(ntSourcesDependency)
        ntSourcesDependency.setTransitive(false)
        def ntSources = ntSourcesConfig.singleFile
    }
    doLast {
        from zipTree(ntSources)
        exclude 'META-INF/*'
        into ntSourceDir
    }
}

task javadoc(type: Javadoc, overwrite: true) {
    dependsOn unzipJavaNtSources
    source sourceSets.athena.allJava, sourceSets.shared.allJava, unzipJavaNtSources.outputs.files
    classpath = files([sourceSets.athena.compileClasspath, sourceSets.shared.compileClasspath])
    javadoc.options.links("http://docs.oracle.com/javase/8/docs/api/")
    options.addStringOption "tag", "pre:a:Pre-Condition"
//    options.addStringOption('Xdoclint:accessibility,syntax,reference,html', '-quiet')
}

task wpilibjJavadoc(type: Jar, dependsOn: javadoc) {
    description = 'Creates the javadoc jar for the maven publishing routine'
    group = 'WPILib'
    classifier = 'javadoc'
    duplicatesStrategy = 'exclude'

    from javadoc.destinationDir
}

task jniHeaders {
    description = 'Generates JNI headers from edu.wpi.first.wpilibj.hal.*'
    group = 'WPILib'
    def outputFolder = file(generatedJNIHeaderLoc)
    inputs.files sourceSets.athena.output
    outputs.file outputFolder
    doLast {
        outputFolder.mkdirs()
        exec {
            executable org.gradle.internal.jvm.Jvm.current().getExecutable('javah')
            args '-d', outputFolder
            args '-classpath', sourceSets.athena.output.classesDir
            args 'edu.wpi.first.wpilibj.can.CANJNI'
            args 'edu.wpi.first.wpilibj.hal.FRCNetComm'
            args 'edu.wpi.first.wpilibj.hal.HAL'
            args 'edu.wpi.first.wpilibj.hal.HALUtil'
            args 'edu.wpi.first.wpilibj.hal.JNIWrapper'
            args 'edu.wpi.first.wpilibj.hal.AccelerometerJNI'
            args 'edu.wpi.first.wpilibj.hal.AnalogJNI'
            args 'edu.wpi.first.wpilibj.hal.AnalogGyroJNI'
            args 'edu.wpi.first.wpilibj.hal.ConstantsJNI'
            args 'edu.wpi.first.wpilibj.hal.CounterJNI'
            args 'edu.wpi.first.wpilibj.hal.DigitalGlitchFilterJNI'
            args 'edu.wpi.first.wpilibj.hal.DIOJNI'
            args 'edu.wpi.first.wpilibj.hal.EncoderJNI'
            args 'edu.wpi.first.wpilibj.hal.I2CJNI'
            args 'edu.wpi.first.wpilibj.hal.InterruptJNI'
            args 'edu.wpi.first.wpilibj.hal.NotifierJNI'
            args 'edu.wpi.first.wpilibj.hal.PortsJNI'
            args 'edu.wpi.first.wpilibj.hal.PWMJNI'
            args 'edu.wpi.first.wpilibj.hal.RelayJNI'
            args 'edu.wpi.first.wpilibj.hal.SPIJNI'
            args 'edu.wpi.first.wpilibj.hal.SolenoidJNI'
            args 'edu.wpi.first.wpilibj.hal.CompressorJNI'
            args 'edu.wpi.first.wpilibj.hal.PDPJNI'
            args 'edu.wpi.first.wpilibj.hal.PowerJNI'
            args 'edu.wpi.first.wpilibj.hal.SerialPortJNI'
        }
    }
}

task wpilibjNativeLibraries(type: Jar) {
    description = 'Creates the native library jar for the maven publishing routine'
    baseName = 'nativelibraries'
    group = 'WPILib'
    duplicatesStrategy = 'exclude'
    dependsOn project(':wpilibj').jniHeaders

    // Include the JNI library
    model {
        binaries {
            withType(SharedLibraryBinarySpec) { spec ->
                from(spec.sharedLibraryFile) {
                    into 'lib'
                }
                from(new File(spec.sharedLibraryFile.absolutePath + ".debug")) {
                    into 'lib'
                }
            }
        }
    }
    project(':wpilibj').jniHeaders.outputs.each {
            from(it) {
                into 'include'
            }
        }
}

build.dependsOn wpilibjNativeLibraries

clean {
    delete generatedJNIHeaderLoc
    delete ntSourceDir
}
